别人的总结： http://aaronplay.me/2014/10/27/alogrithm-structure/
Brute Force 暴力法（枚举）:
这是我们最容易想到，就是一个个地尝试，相当万能的解法，但这种情况只适用于在计算机强大的能力下。这样的代码一般都是很短的，读起来也是最省力了。但一般不用，因为计算机可以帮助我们做得更多。
优化：空间换时间 hastable
数组和链表是很相似的数据结构，区别在于：
  **空间**  
  数组：需要预分配，耗空间  
  链表：按需分配 

  **访问效率**  
  数组：支持随机访问  
  链表：不支持


Leetcode summary---树的构造



Leetcode summary---kSum：
	Two Sum
	3Sum
	3Sum Closest
	4Sum
	首先从Two Sum开始， 这道题目提供了后面k>2的题目的基本思路， 也是最常考到的题目（亚马逊的面试对这道题算是情有独钟了）。 主要有两种思路， 一种是利用哈希表对元素的出现进行记录，然后进来新元素时看看能不能与已有元素配成target， 如果哈希表的访问是常量操作，这种算法复杂度是O(n)。 另一种思路则是先对数组进行排序， 然后利用夹逼的方法找出满足条件的pair， 算法的复杂度是O(nlogn)。 两种方法都比brute force的O(n^2)要优， 具体可以参见题目Two Sum的具体分析。 因为这道题模型简单， 但是可以考核到哈希表等基本数据结构和排序等基本算法， 所以是面试中的常客。
	接下来是3Sum和3Sum Closest， 3Sum是使用Two Sum的第二种方法作为子操作， 然后循环每个元素， 寻找剩下的元素满足条件的pair即可。 3Sum Closest和3Sum很类似， 只是要多维护一个最小的diff， 保存和target最近的值。 算法的复杂度是O(n^2)， 这道题使用Two Sum的第一种方法并不合适， 因为当出现元素重复时用哈希表就不是很方便了。
	最后是4Sum， 这道题的比较优的解法是用求解一般kSum的解法进行层层二分， 然后用Two Sum结合起来， 基本思路是这样， 实现细节还是比较复杂的， 即使是4Sum都比较复杂了， 所以面试中难度和实现细节也就到这了， kSum这种一般性的问题只需要知道思路就可以满足面试要求了哈。














	